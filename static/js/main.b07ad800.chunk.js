(this["webpackJsonptypescript-presentation-new-bull"]=this["webpackJsonptypescript-presentation-new-bull"]||[]).push([[1],{308:function(e,n,t){e.exports=t.p+"static/media/Hasse_diagram_of_powerset_of_3.4ee60547.svg"},309:function(e,n,t){e.exports=t.p+"static/media/Hasse_diagram_of_type_system.641583bd.svg"},313:function(e,n,t){e.exports=t(490)},318:function(e,n,t){},406:function(e,n,t){var r={"./lib.dom.d.ts":407,"./lib.dom.iterable.d.ts":408,"./lib.es2015.collection.d.ts":409,"./lib.es2015.core.d.ts":410,"./lib.es2015.d.ts":411,"./lib.es2015.generator.d.ts":412,"./lib.es2015.iterable.d.ts":413,"./lib.es2015.promise.d.ts":414,"./lib.es2015.proxy.d.ts":415,"./lib.es2015.reflect.d.ts":416,"./lib.es2015.symbol.d.ts":417,"./lib.es2015.symbol.wellknown.d.ts":418,"./lib.es2016.array.include.d.ts":419,"./lib.es2016.d.ts":420,"./lib.es2016.full.d.ts":421,"./lib.es2017.d.ts":422,"./lib.es2017.full.d.ts":423,"./lib.es2017.intl.d.ts":424,"./lib.es2017.object.d.ts":425,"./lib.es2017.sharedmemory.d.ts":426,"./lib.es2017.string.d.ts":427,"./lib.es2017.typedarrays.d.ts":428,"./lib.es2018.asyncgenerator.d.ts":429,"./lib.es2018.asynciterable.d.ts":430,"./lib.es2018.d.ts":431,"./lib.es2018.full.d.ts":432,"./lib.es2018.intl.d.ts":433,"./lib.es2018.promise.d.ts":434,"./lib.es2018.regexp.d.ts":435,"./lib.es2019.array.d.ts":436,"./lib.es2019.d.ts":437,"./lib.es2019.full.d.ts":438,"./lib.es2019.object.d.ts":439,"./lib.es2019.string.d.ts":440,"./lib.es2019.symbol.d.ts":441,"./lib.es2020.bigint.d.ts":442,"./lib.es2020.d.ts":443,"./lib.es2020.full.d.ts":444,"./lib.es2020.intl.d.ts":445,"./lib.es2020.promise.d.ts":446,"./lib.es2020.string.d.ts":447,"./lib.es2020.symbol.wellknown.d.ts":448,"./lib.es5.d.ts":449,"./lib.es6.d.ts":450,"./lib.esnext.d.ts":451,"./lib.esnext.full.d.ts":452,"./lib.esnext.intl.d.ts":453,"./lib.esnext.promise.d.ts":454,"./lib.esnext.string.d.ts":455,"./lib.scripthost.d.ts":456,"./lib.webworker.d.ts":457,"./lib.webworker.importscripts.d.ts":458};function a(e){var n=l(e);return t(n)}function l(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}a.keys=function(){return Object.keys(r)},a.resolve=l,e.exports=a,a.id=406},459:function(e,n,t){"use strict";t.r(n),n.default="const array_type_demo0: number[] = [1, 2, 3];\nconst array_type_demo1: Array<number> = [1, 2, 3];\n\nconst array_type_demo2: ReadonlyArray<number> = [1, 2, 3];\nconst array_type_demo3: readonly number[] = [1, 2, 3];\n\nconst array_type_demo0_length = array_type_demo0.length;\n\ntype array_type_length = Array<string>['length'];\n"},460:function(e,n,t){"use strict";t.r(n),n.default="const falseValue = false;\nlet booleanValue = true;\n\nlet trueValue = true as const;\n\nconst numberValue255 = 0xff;\nconst bigintValue = -0b10;\n\nlet numberValue = 255;\n\nconst stringHelloWorld = 'Hello World';\n\nconst symbolValue = Symbol.for('Hello Symbol');\n\nlet symbolValue2 = Symbol.for('Hello Symbol');\n"},461:function(e,n,t){"use strict";t.r(n),n.default="declare let bottom: never;\n\nconst bottom_type_is_assignable_to_type_number: number = bottom;\nconst bottom_type_is_assignable_to_type_string: string = bottom;\nconst bottom_type_is_assignable_to_type_object: object = bottom;\nconst bottom_type_is_assignable_to_type_function: Function = bottom;\nconst bottom_type_is_assignable_to_bottom_type: never = bottom;\n\n// @ts-expect-error\nbottom = 1;\n// @ts-expect-error\nbottom = '';\n// @ts-expect-error\nbottom = {};\n"},462:function(e,n,t){"use strict";t.r(n),n.default="function infinity_loop(): never {\n  // type system \u4e00\u822c\u662f incomplete \u7684\n  // while (1 === 1) {}\n  while (true) {}\n  console.log('Unreachable code detected.');\n}\n\ninfinity_loop();\nconsole.log('Unreachable code detected.');\n"},463:function(e,n,t){"use strict";t.r(n),n.default="function throw_error(): never {\n  throw new Error('');\n  console.log('Unreachable code detected.');\n}\n\nthrow_error();\nconsole.log('Unreachable code detected.');\n"},464:function(e,n,t){"use strict";t.r(n),n.default="interface ClassTypeDemo1Interface {\n  bar(): string;\n}\n\nclass ClassTypeDemo1 implements ClassTypeDemo1Interface {\n  baz;\n\n  tux?: Object;\n  constructor(\n    private readonly foo: number,\n    bar: { v: readonly [number, { readonly x: string }] },\n  ) {\n    this.baz = bar.v;\n  }\n\n  bar() {\n    return '';\n  }\n}\n"},465:function(e,n,t){"use strict";t.r(n),n.default="type PromiseType<T extends Promise<unknown>> = T extends Promise<infer R>\n  ? R\n  : 'any_type_here_is_ok';\n\ntype PromiseTypeDemo = PromiseType<Promise<[number, string]>>;\n\nnamespace arithmetic {\n  type Equal<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;\n\n  type Nat = Array<undefined>;\n  type Zero = [];\n  type Succ<T extends Nat> = [undefined, ...T];\n\n  // prettier-ignore\n  type Prev<T extends Nat> = T extends [undefined, ...infer p] ? p : Zero;\n\n  type Plus<A extends Nat, B extends Nat> = A extends Zero\n    ? B\n    : Plus<Prev<A>, Succ<B>>;\n\n  type Plus_v2<A, B> = A extends Nat\n    ? B extends Nat\n      ? Plus<A, B>\n      : never\n    : never;\n\n  type NatToNumber<T extends Nat> = T['length'];\n\n  type NumberToNatHelper<T extends number, N extends Nat> = true extends Equal<\n    N['length'],\n    T\n  >\n    ? N\n    : NumberToNatHelper<T, Succ<N>>;\n\n  type NumberToNat<T extends number> = NumberToNatHelper<T, Zero>;\n\n  // @ts-expect-error Type instantiation is excessively deep and possibly infinite.\n  export type add<a extends number, b extends number> = NatToNumber<\n    // @ts-expect-error\n    Plus_v2<NumberToNat<a>, NumberToNat<b>>\n  >;\n}\n\ntype eleven = arithmetic.add<6, 5>;\n\nfunction add<A extends number, B extends number>(\n  a: A,\n  b: B,\n): A extends number\n  ? B extends number\n    ? arithmetic.add<A, B>\n    : never\n  : never {\n  return (a + b) as any;\n}\n\ndeclare const value123: 1 | 2 | 3;\ndeclare const value134: 1 | 3 | 4;\n\nconst valueAdded = add(value123, value134);\n"},466:function(e,n,t){"use strict";t.r(n),n.default="[1, 2, 3].map(x => x + 1);\n"},467:function(e,n,t){"use strict";t.r(n),n.default="const X: string = ''; // Value named X\n\ntype X = { y: number }; // Type named X\n\nnamespace X {\n  // Namespace named X\n  export type Y = string;\n}\nconst n: X = { y: 1 }; // X references type\nconst s: X.Y = X; // First X references namespace, second X references value\nconst r: X['y'] = 2; // X references type\n\n/**\n * Value and type named C\n */\nclass C {\n  // Instance and static members in a class are in separate declaration spaces\n  x?: string; // Instance member\n  static x: string = '123'; // Static member\n}\n\n// typeof C\nconst C2 = C;\n\nconst C3: { new (): C } = C;\n\nconst C4: new () => C = C;\n"},468:function(e,n,t){"use strict";t.r(n),n.default="enum Status {\n  OK,\n  Error,\n}\n\ntype Result<V, E> =\n  | {\n      status: Status.OK;\n      value: V;\n    }\n  | {\n      status: Status.Error;\n      error: E;\n    };\n\ndeclare const a: Result<string, number>;\n\nfunction exhaustiveCheck(v: never) {}\n\nif (a.status === Status.OK) {\n  a.value;\n} else if (a.status === Status.Error) {\n  a.error;\n} else {\n  exhaustiveCheck(a);\n}\n"},469:function(e,n,t){"use strict";t.r(n),n.default="const any_type_is_assignable_to_type_any: any = 1;\nconst type_any_is_assignable_to_any_type_such_as_string: string = any_type_is_assignable_to_type_any;\n"},470:function(e,n,t){"use strict";t.r(n),n.default="async function asyncFunctionReturn1() {\n  return 1;\n}\n\nconst add_v1: (a: number) => (b: number) => number = (\n  a: number,\n): ((b: number) => number) => (b: number): number => a + b;\n\nconst add_v2 = (a: number) => (b: number) => a + b;\n\nconst sum_of_all = (...xs: ReadonlyArray<number>) =>\n  xs.reduce((a, b) => a + b, 0);\n\nfunction add_v3(a: number, b: number): number;\nfunction add_v3(a: bigint, b: bigint): bigint;\nfunction add_v3(a: number | bigint, b: number | bigint) {\n  // \u5b9e\u73b0\u5f80\u5f80\u7c7b\u578b\u4e0d\u5b89\u5168\n  // @ts-expect-error\n  return a + b;\n}\n\n// prettier-ignore\nconst add_v4:\n  & ((a: number, b: number) => number)\n  & ((a: bigint, b: bigint) => bigint)\n  = add_v3;\n\nfunction identity<T>(x: T) {\n  return x;\n}\n\nconst identityOf1 = identity(1);\n\nfunction map<X, Y>(xs: ReadonlyArray<X>, mapper: (x: X) => Y) {\n  return xs.map(mapper);\n}\n"},471:function(e,n,t){"use strict";t.r(n),n.default="function pluck<T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {\n  return propertyNames.map(n => o[n]);\n}\n\ninterface Car {\n  manufacturer: string;\n  model: string;\n  year: number;\n}\nlet taxi: Car = {\n  manufacturer: 'Toyota',\n  model: 'Camry',\n  year: 2014,\n};\n\n// Manufacturer and model are both of type string,\n// so we can pluck them both into a typed string array\nlet makeAndModel: string[] = pluck(taxi, ['manufacturer', 'model']);\n\n// If we try to pluck model and year, we get an\n// array of a union type: (string | number)[]\nlet modelYear = pluck(taxi, ['model', 'year']);\n\nfunction getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {\n  return o[propertyName]; // o[propertyName] is of type T[K]\n}\n\nlet nameOfTaxi: string = getProperty(taxi, 'manufacturer');\nlet year: number = getProperty(taxi, 'year');\n\n// @ts-expect-error 'unknown' is not in 'manufacturer' | 'model' | 'year'\nlet unknown = getProperty(taxi, 'unknown');\n"},472:function(e,n,t){"use strict";t.r(n),n.default="type Loggable = {\n  log(name: string): void;\n};\ntype HasName = {\n  readonly name: string;\n};\n\ntype HasNameAndLoggable = Loggable & HasName;\n\n// prettier-ignore\ntype IntersectionsReducedByDiscriminantProperties =\n  & { kind: 'foo' }\n  & { kind: 'bar' };\n"},473:function(e,n,t){"use strict";t.r(n),n.default="interface Person {\n  name: string;\n  age: number;\n}\n\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\ntype MyPartial<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype PersonPartial = MyPartial<Person>;\ntype ReadonlyPerson = MyReadonly<Person>;\n"},474:function(e,n,t){"use strict";t.r(n),n.default="const object_type_demo_1: object = {};\nconst object_type_demo_2: object = [];\n// @ts-expect-error\nconst object_type_demo_3: object = 1;\n// @ts-expect-error\nconst object_type_demo_3: object = undefined;\n"},475:function(e,n,t){"use strict";t.r(n),n.default="function incomplete_demo_1() {\n  let a: number;\n  [1].forEach(() => {\n    a = 1;\n  });\n  // @ts-expect-error\n  console.log(1 + a);\n}\n\nfunction unsound_demo_1() {\n  let a: number;\n  [].forEach(() => {\n    a = 1;\n  });\n  const run = () => {\n    console.log(a + 1);\n  };\n  run();\n}\n\nfunction unsound_demo_2(arr: Array<string>) {\n  const itShouldBeStringOrUndefined = arr[10];\n  console.log(itShouldBeStringOrUndefined.toLowerCase());\n  console.log(arr[-1].length);\n}\n\nfunction unsound_demo_3() {\n  const subTypeArray: Array<{ x: string; y: { z: string } }> = [];\n  const superTypeArray: Array<{ x: string }> = subTypeArray;\n  superTypeArray.unshift({ x: '123' });\n  console.log(subTypeArray[0].y.z);\n}\n\nconst sleep = (ms: number) =>\n  new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n\nclass unsound_demo_4 {\n  public foo?: string;\n\n  async run() {\n    if (this.foo === undefined) {\n      return;\n    }\n    await sleep(1000);\n    console.log(`foo is ${this.foo} and length is ${this.foo.length}`);\n  }\n}\n\nasync function unsound_demo_5(bar: { baz: number | string }) {\n  if (typeof bar.baz === 'number') {\n    await sleep(1000);\n    console.log(bar.baz.toFixed());\n  }\n}\n"},476:function(e,n,t){"use strict";t.r(n),n.default="enum Gender {\n  male = 'male',\n  female = 'female',\n}\n\nconst enum Gender2 {\n  male = 'male',\n  female = 'female',\n}\n\ntype gender = 'male' | 'female';\n"},477:function(e,n,t){"use strict";t.r(n),n.default="interface Named {\n  name: string;\n}\n\nclass Person {\n  name: string = '';\n}\n\nlet p: Named;\n// OK, because of structural typing\np = new Person();\n"},478:function(e,n,t){"use strict";t.r(n),n.default="declare let top_value: unknown;\n\n// @ts-expect-error\nconst top_type_is_assignable_to_type_number: number = top_value;\n// @ts-expect-error\nconst top_type_is_assignable_to_type_string: string = top_value;\n// @ts-expect-error\nconst top_type_is_assignable_to_type_object: object = top_value;\n// @ts-expect-error\nconst top_type_is_assignable_to_type_function: Function = top_value;\n// @ts-expect-error\nconst top_type_is_assignable_to_bottom_type: never = top_value;\n\ntop_value = 1;\ntop_value = '';\ntop_value = {};\n"},479:function(e,n,t){"use strict";t.r(n),n.default="type TupleTypeDemo = readonly [name: string, age?: number];\n\nconst xianbei: TupleTypeDemo = ['\u7530\u6240\u6d69\u4e8c', 24];\n\ntype TupleTypeDemo2 = [string, number?];\n\nconst jiege: TupleTypeDemo2 = ['\u6770\u54e5'];\njiege[1] = 114514;\n\nconst the_answer = ['the answer to life the universe and everything', 'is', 42] as const;\n\nconst jiege_length = jiege.length\n\ntype TupleTypeDemo_length = TupleTypeDemo['length']\n"},480:function(e,n,t){"use strict";t.r(n),n.default="function isNotNil<T>(x: T): x is NonNullable<T> {\n  return x != null;\n}\n\nconst type_guard_demo_1 = [1, 2, '', undefined, null].filter(isNotNil);\n\nfunction type_guard_demo_2(x?: string) {\n  return typeof x === 'string' ? x.length : -1;\n}\n\nfunction assertNotNil<T>(x: T): asserts x is NonNullable<T> {\n  if (x == null) {\n    throw new Error();\n  }\n}\n\nfunction asserts_demo_1(x?: string) {\n  assertNotNil(x);\n  return x.length;\n}\n\nfunction assert(x: unknown): asserts x {\n  if (!x) {\n    throw new Error();\n  }\n}\n\nfunction asserts_demo_2(x?: Array<number>) {\n  assert(x instanceof Array);\n  return x.length;\n}\n"},481:function(e,n,t){"use strict";t.r(n),n.default="// @ts-expect-error 'quick_sort' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\nfunction quick_sort(xs: ReadonlyArray<number>) {\n  if (xs.length === 0) {\n    return xs;\n  }\n  const [head, ...tail] = xs;\n  return [\n    ...quick_sort(tail.filter(x => x < head)),\n    head,\n    ...quick_sort(tail.filter(x => x >= head)),\n  ];\n}\n\nconst filter = <X>(predicate: (value: X) => boolean) => (\n  xs: ReadonlyArray<X>,\n) => xs.filter(predicate);\n\n// @ts-expect-error\nconst numbers: number[] = filter(x => x !== 1)([1, 2, 3, 4]);\n"},482:function(e,n,t){"use strict";t.r(n),n.default="type Equal<T, U> = [T] extends [U] ? ([U] extends [T] ? true : false) : false;\n\ntype a = {\n  foo: number;\n  bar: string;\n};\n\ntype b = {\n  bar: string;\n  baz: boolean;\n};\n\ntype c = {\n  foo: number;\n  baz: boolean;\n};\n\n// \u5b50\u7c7b\u578b\u5173\u7cfb\u662f\u4e00\u4e2a\u7c7b\u578b\u4e0a\u7684\u975e\u4e25\u683c\u504f\u5e8f\u5173\u7cfb\uff0c\u5b58\u5728\u4e8c\u5143\u8fd0\u7b97 union \u548c intersection \u6ee1\u8db3\u4e09\u4e2a\u516c\u7406\n// \u4e09\u4e2a\u516c\u7406\u6052\u7b49\u5f0f\uff0c for all a, b, c \u2208 Type\uff0c\n// \u4ea4\u6362\u5f8b\ntype CommutativeLaw1 = Equal<a | b, b | a>;\ntype CommutativeLaw2 = Equal<a & b, b & a>;\n// \u7ed3\u5408\u5f8b\ntype AssociativeLaw1 = Equal<a | (b | c), (a | b) | c>;\ntype AssociativeLaw2 = Equal<a & (b & c), (a & b) & c>;\n// \u5438\u6536\u5f8b\ntype AbsorptionLaw1 = Equal<a | (a & b), a>;\ntype AbsorptionLaw2 = Equal<a & (a | b), a>;\n\n// \u53ef\u4ee5\u63a8\u51fa \u5e42\u7b49\u5f8b\ntype IdempotentLaw1 = Equal<a, a | a>;\ntype IdempotentLaw2 = Equal<a, a & a>;\n\n// \u800c\u4e14\u5b58\u5728 \u22a4 \u548c \u22a5\ntype neverIsTheBottomType = never extends a ? true : false;\ntype unknownIsTheTopType = a extends unknown ? true : false;\n// \u6216\u8005\u53ef\u4ee5\u5b9a\u4e49\u6052\u7b49\u5f8b\ntype IdentityLaw1 = Equal<a & unknown, a>;\ntype IdentityLaw2 = Equal<a | never, a>;\n\n// \uff08Type, union, intersection, never, unknown\uff09\u6784\u6210\u4e00\u4e2a bounded lattice\n"},483:function(e,n,t){"use strict";t.r(n),n.default="type Handler = Function;\nconst key = 'key';\n\ntype Foo = {\n  baz: [\n    1,\n    number,\n    {\n      y: Array<string>;\n    },\n  ];\n  readonly handler: Handler;\n  toString(): string;\n  readonly [Symbol.iterator]: '123';\n  [key]: 2333;\n  0x1: 'foo';\n  bar: number;\n};\n"},484:function(e,n,t){"use strict";t.r(n),n.default="type NumberType = number | number;\ntype NumberOrString = NumberType | string;\nconst numberOrStringArray: Array<NumberOrString> = [1, '2333'];\n"},485:function(e,n,t){"use strict";t.r(n),n.default="const undef = undefined;\nconst nil = null;\n\nlet null_in_let_infer_any = null;\nlet undefined_in_let_infer_any = undefined;\n\n// @ts-expect-error\nconst undefined_is_not_null: undefined = null;\n\n// @ts-expect-error\nconst null_is_not_undefined: null = undefined;\n\n// @ts-expect-error\nconst undefined_is_not_number: number = undefined;\n"},486:function(e,n,t){"use strict";t.r(n),n.default="type is_a_supertype_of<a, b> = [b] extends [a] ? true : false;\n\ndeclare let value_of_supertype: number;\ndeclare let value_of_subtype: 1;\nvalue_of_supertype = value_of_subtype; // OK\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nvalue_of_subtype = value_of_supertype;\n\ntype variance_test = is_a_supertype_of<number, 1>;\n\n/*\n * contravariant\n */\n\ndeclare let parameter_is_supertype: (a: number) => void;\ndeclare let parameter_is_subtype: (a: 1) => void;\n\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nparameter_is_supertype = parameter_is_subtype;\nparameter_is_subtype = parameter_is_supertype; // OK\n\ntype contravariant_test = is_a_supertype_of<\n  (a: 1) => void,\n  (a: number) => void\n>;\n\n/*\n * covariant\n */\ndeclare let return_is_supertype: () => number;\ndeclare let return_is_subtype: () => 1;\n\nreturn_is_supertype = return_is_subtype; // OK\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nreturn_is_subtype = return_is_supertype;\n\ntype covariant_test = is_a_supertype_of<() => number, () => 1>;\n\n/*\n * invariant\n */\n\ndeclare let parameter_and_return_is_supertype: (a: number) => number;\ndeclare let parameter_and_return_is_subtype: (a: 1) => 1;\n\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nparameter_and_return_is_supertype = parameter_and_return_is_subtype;\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nparameter_and_return_is_subtype = parameter_and_return_is_supertype;\n\n// false\ntype invariant_test_1 = is_a_supertype_of<(a: number) => number, (a: 1) => 1>;\n// false\ntype invariant_test_2 = is_a_supertype_of<(a: 1) => 1, (a: number) => number>;\n"},487:function(e,n,t){"use strict";t.r(n),n.default="const variance_test_value = [{ x: 114 }, { y: { z: 514 } }] as const;\n\nlet func_parameter_is_supertype: (a: number) => void;\n\nconst func_parameter_is_subtype: (a: 1) => void = a => {\n  console.log(variance_test_value[a].y.z);\n};\n\n// @ts-expect-error Type 'number' is not assignable to type '1'.\nfunc_parameter_is_supertype = func_parameter_is_subtype;\n\nfunc_parameter_is_supertype(0); // Uncaught TypeError: Cannot read property 'z' of undefined\n"},488:function(e,n,t){"use strict";t.r(n),n.default="function noop() {}\n\nconst type_undefined_is_assignable_to_type_void: void = undefined;\n\n// @ts-expect-error\nconst type_number_is_not_assignable_to_type_void: void = 1;\n"},490:function(e,n,t){"use strict";t.r(n);var r=t(2),a=t(300),l=(t(318),t(21)),s=t(182);const o=t(406);function i({value:e,style:n}){const t=Object(r.useRef)(null);return Object(r.useEffect)(()=>{const n=s.editor.create(t.current,{value:e,language:"typescript",fontSize:24,theme:"vs-dark"});return()=>n.dispose()},[]),r.createElement("div",{ref:t,style:{height:"70vh",...n}})}s.languages.typescript.typescriptDefaults.setCompilerOptions({target:s.languages.typescript.ScriptTarget.ESNext,allowNonTsExtensions:!0,strict:!0}),o.keys().map(e=>({filename:e,content:o(e).default})).forEach(({filename:e,content:n})=>{s.languages.typescript.typescriptDefaults.addExtraLib(n,e)});var u={array_type:t(459).default,boolean_number_bigint_string_symbol:t(460).default,bottom_type_assignment:t(461).default,bottom_type_infinity_loop:t(462).default,bottom_type_throw_error:t(463).default,class_type:t(464).default,conditional_types:t(465).default,contextual_typing:t(466).default,declaration_spaces:t(467).default,discriminated_union:t(468).default,dynamic_typing_any:t(469).default,function_type:t(470).default,index_types:t(471).default,intersection_type:t(472).default,mapped_types:t(473).default,object_type:t(474).default,soundness_and_completeness:t(475).default,string_literals_and_enum_types:t(476).default,structural_typing:t(477).default,top_type:t(478).default,tuple_type:t(479).default,type_guards_and_asserts:t(480).default,type_inference:t(481).default,type_lattice:t(482).default,type_literals:t(483).default,union_type:t(484).default,unit_type:t(485).default,variance:t(486).default,variance_bivariance:t(487).default,void_type:t(488).default},c=t(308),p=t.n(c),m=t(309),y=t.n(m);var d=function(){return r.createElement(l.d,null,r.createElement(l.n,null,r.createElement(l.f,null,"TypeScript 101"),r.createElement(l.j,null,"### ZHAO Jinxiang")),r.createElement(l.n,null,r.createElement(l.f,null,"Welcome to TypeScript"),r.createElement(l.j,null,"\nTOC\n\n* \u7c7b\u578b\u5165\u95e8\u4ecb\u7ecd\u548c\u5de5\u5177\u914d\u7f6e\n* \u57fa\u672c\u7c7b\u578b\n* \u7ec4\u5408\u7c7b\u578b\uff0ctype constructor\uff0cvariance\uff0ctype lattice\n* advanced types\n          ")),r.createElement(l.n,null,r.createElement(l.j,null,"\n\u7c7b\u578b\u7cfb\u7edf\u662f\u8fd9\u6837\u4e00\u4e2a\u4e1c\u897f\uff1a\n\n* \u5728\u6709\u4e9b\u4eba\u773c\u91cc\u5b83\u5f88\u590d\u6742\uff0c\u5904\u5904\u7ed9\u81ea\u5df1\u6dfb\u9ebb\u70e6\uff0c\u788d\u624b\u788d\u811a\u3002\n* \u53e6\u5916\u4e00\u4e9b\u4eba\u8fd0\u7528\u5b83\u6982\u8ff0\u548c\u9650\u5236\u4e00\u4e2a\u7cfb\u7edf\uff0c\u4f7f\u5f97\u7f16\u7a0b\u53d8\u6210\u8fd9\u6837\u4e00\u79cd\u6d3b\u52a8\n   1. \u4ece\u5168\u5c40\u601d\u8003\u65b0\u7684\u7cfb\u7edf\u7ea6\u675f\uff0c\u6216\u7ea6\u675f\u66f4\u6539\u5e94\u8be5\u662f\u4ec0\u4e48\n   2. \u4ece\u5168\u5c40\u601d\u8003\u5982\u4f55\u5f15\u5165\u65b0\u7684\u4fe1\u606f\u548c\u8ba9\u4fe1\u606f\u600e\u6837\u6d41\u52a8\u53ef\u4ee5\u6ee1\u8db31\u6240\u63d0\u51fa\u7684\u65b0\u7ea6\u675f\n   3. \u6839\u636e1\u548c2 \u8c03\u6574\u7c7b\u578b\u5b9a\u4e49\n   4. \u6839\u636e\u7f16\u8bd1\u5668\u7684\u9519\u8bef\u63d0\u793a\u66f4\u6539\u4ee3\u7801\n")),r.createElement(l.n,null,r.createElement(l.n,null,r.createElement(l.j,null,"\n\u8fd9\u4e2a\u8fc7\u7a0b\u770b\u8d77\u6765\u5f88\u590d\u6742\uff0c\u5176\u5b9e\u57fa\u672c\u4e0a\u5c31\u662f\u601d\u800310%\u7684\u65f6\u95f4\uff0c\u7136\u540e90%\u7684\u65f6\u95f4\u4e00\u8fb9\u770b\u7535\u89c6\u6216\u8005\u7535\u5f71\uff0c\u4e00\u8fb9\u65e0\u8111\u6539\u7a0b\u5e8f\u7684\u8fc7\u7a0b\uff0c\u6539\u5b8c\u4e86\u90fd\u4e0d\u77e5\u9053\u81ea\u5df1\u6539\u4e86\u5565\u3002\u7136\u540e\u4e00\u8dd1test\u5168\u8fc7\u3002\n\u8fd9\u79cd\u5f00\u53d1\u65b9\u5f0f\u53c8\u53eb\u505acareless driven programming\uff0c\u5373\uff1a\u5373\u4f7f\u4e09\u5fc3\u4e8c\u610f\uff0c\u4e5f\u53ef\u4ee5\u5199\u51fa\u6b63\u786e\u7684\u7a0b\u5e8f\uff0c\u4e14\u4fdd\u6301\u7cfb\u7edf\u53ef\u4ee5\u4e09\u5fc3\u4e8c\u610f\u7684\u66f4\u6539\u7684\u5c5e\u6027\u3002\u8fd9\u91cc\u7684\u91cd\u4e2d\u4e4b\u91cd\uff0c\u662f\u8981maintain\u7cfb\u7edf\u7684\u201c\u4e09\u5fc3\u4e8c\u610f\u201d\u6027\u3002\n\nby \u963f\u840a\u514b\u897f\u65af\n")),r.createElement(l.f,null,"Introduction to typing"),r.createElement(l.s,null,r.createElement(l.i,null,"\u57fa\u672c\u672f\u8bed"),r.createElement(l.i,null,"\u5e38\u89c1\u7684\u7c7b\u578b\u7cfb\u7edf",r.createElement(l.s,null,r.createElement(l.i,null,"Dynamic typing / Static typing"),r.createElement(l.i,null,"Nominal typing / Structural typing"),r.createElement(l.i,null,"Gradual typing"))))),r.createElement(l.n,null,r.createElement("div",null,r.createElement(l.j,null,"\n\u57fa\u672c\u672f\u8bed\n\n* term: \u9879\uff0c\u4e00\u4e2a\u8868\u8fbe\u5f0f\n* type: \u4e00\u4e2a\u6709\u76f8\u540c\u6027\u8d28\u7684 term \u7684\u96c6\u5408\n* typing context/environment \u5b9a\u578b\u73af\u5883: Map<[\u53d8\u91cf\u540d,\u7c7b\u578b]>\n* typing: \u5728\u67d0\u4e2a context \u4e2d\u8d4b\u4e88\u67d0\u4e2a term \u4ee5\u67d0\u4e2a type\n* typed: term \u88ab\u6807\u4e0a type \u5566\n* typing rule: \u5df2\u77e5 typing environment \u4e2d\u7684\u67d0\u4e9b term \u7684\u7c7b\u578b\uff0c\u63a8\u51fa\u65b0\u7684\u67d0\u4e9b term \u7684 type \u7684\u89c4\u5219\n* type checking: \u786e\u8ba4 term \u662f\u5426\u80fd\u5728 context \u4e2d\u6807\u8bb0\u6210 type\n"))),r.createElement(l.n,null,r.createElement(l.r,null,"\u5e38\u89c1\u7684\u7c7b\u578b\u7cfb\u7edf"),r.createElement(l.s,null,r.createElement(l.i,null,"Dynamic typing / Static typing"),r.createElement(l.i,null,"Nominal typing / Structural typing"),r.createElement(l.i,null,"Gradual typing"))),r.createElement(l.n,null,r.createElement(l.f,null,"\u73af\u5883\u914d\u7f6e"),r.createElement(l.s,null,r.createElement(l.i,null,"node"),r.createElement(l.i,null,"vscode"),r.createElement(l.i,null,"ts-node"))),r.createElement(l.n,null,r.createElement(l.f,null,"Basic Types")),r.createElement(l.n,null,r.createElement(l.r,null,"undefined / null"),r.createElement(i,{value:u.unit_type})),r.createElement(l.n,null,r.createElement(l.r,null,"boolean / number / bigint / string / symbol"),r.createElement(i,{value:u.boolean_number_bigint_string_symbol})),r.createElement(l.n,null,r.createElement(l.r,null,"void"),r.createElement(l.r,null,"void \u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u7c7b\u578b\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u7b49\u4ef7\u4e8e any\uff0c\u5927\u90e8\u5206\u60c5\u51b5\u4e0b\u7c7b\u4f3c\u4e8e undefined \u7684\u522b\u540d"),r.createElement(i,{value:u.void_type})),r.createElement(l.n,null,r.createElement(l.r,null,"bottom type / never / 0"),r.createElement(l.r,null,"\u7c7b\u578b\u8bba\u4e2d\u5e95\u7c7b\u578b(\u5e38\u5e38\u88ab\u8bb0\u4e3aup tack (\u22a5) symbol)\uff0c\u5728 ts \u4e2d\u5bf9\u5e94\u7684\u662f never\uff0c\u8fd9\u4e2a type \u53ea\u6709 0 \u4e2a\u5b9e\u9645\u7684 instance\uff0c\u591a\u7528\u4e8e\u8868\u793a\u6b7b\u5faa\u73af\u6216\u8005\u629b\u9519\u505c\u673a")),r.createElement(l.n,null,r.createElement(l.r,null,"bottom type: infinity loop"),r.createElement(i,{value:u.bottom_type_infinity_loop})),r.createElement(l.n,null,r.createElement(l.r,null,"bottom type: throw error"),r.createElement(i,{value:u.bottom_type_throw_error})),r.createElement(l.n,null,r.createElement(l.r,null,"bottom type: bottom type assignment"),r.createElement(i,{value:u.bottom_type_assignment})),r.createElement(l.n,null,r.createElement(l.r,null,"top type"),r.createElement(l.r,null,"\u7c7b\u578b\u8bba\u4e2d\u7684\u9876\u7c7b\u578b\uff08\u5e38\u88ab\u8bb0\u4e3adown tack symbol (\u22a4)\uff09\uff0c\u5728 ts \u4e2d\u662f unknown\uff0c\u4efb\u4f55\u7c7b\u578b\u90fd\u662f\u5176\u5b50\u7c7b\u578b"),r.createElement(i,{value:u.top_type})),r.createElement(l.n,null,r.createElement(l.r,null,"any"),r.createElement(l.r,null,"\u52a8\u6001\u7c7b\u578b\uff0c\u4e0d\u5b89\u5168\u7684\u7c7b\u578b\uff0c\u5371\u9669\u7684\u529f\u80fd\uff0c\u53ef\u4ee5\u4e0d\u7981\u6b62\uff0c\u4f46\u5f97\u614e\u7528"),r.createElement(i,{value:u.dynamic_typing_any})),r.createElement(l.n,null,r.createElement(l.n,null,r.createElement(l.f,null,"Composing Types"),r.createElement(l.r,null,"type -> type"),r.createElement(l.r,null,"\u63a5\u4e0b\u6765\u7684\u5185\u5bb9\u90fd\u662f\u7ec4\u5408\u4e0a\u9762\u7684\u7c7b\u578b\uff0c\u4e3b\u8981\u4ecb\u7ecd\u5404\u79cd\u7c7b\u578b\u6784\u9020\u5668"))),r.createElement(l.n,null,r.createElement(l.r,null,"Tuple type"),r.createElement(l.r,null,"tuple \u662f\u6700\u5e38\u89c1\u7684\u7c7b\u578b\u6784\u9020\u5668\uff0cjs \u4e2d\u6ca1\u6709 tuple\uff0c\u7531 array \u6765\u6a21\u62df\uff0c\u6bd4\u5982\u4e8c\u5143\u7ec4\u5c31\u662f\u4e00\u4e2a ","(type,type)->type","\u7684\u7c7b\u578b\u6784\u9020\u5668\uff0c\u5e38\u5e38\u7528\u4e8e\u6709\u9650\u957f\u5ea6\u7684\u6570\u636e\u8868\u793a"),r.createElement(i,{value:u.tuple_type})),r.createElement(l.n,null,r.createElement(l.r,null,"Array type"),r.createElement(l.r,null,"Array \u662f\u4e00\u4e2a\u4e00\u5143\u7c7b\u578b\u6784\u9020\u5668 ","type->type","\uff0c\u63a5\u53d7\u4e00\u4e2a\u7c7b\u578b T\uff0c\u8fd4\u56de\u4e00\u4e2a\u65b0\u7c7b\u578b ","Array<T>"),r.createElement(i,{value:u.array_type})),r.createElement(l.n,null,r.createElement(l.j,null,"\nTuple or Array?\n\n* length\n* Number of type parameters\n")),r.createElement(l.n,null,r.createElement(l.r,null,"Type literal / object literal type"),r.createElement(i,{value:u.type_literals})),r.createElement(l.n,null,r.createElement(l.r,null,"Intersection type"),r.createElement(l.r,null,"an intersection type ","\u03c3 & \u03c4"," can be allocated to values that can be assigned both the type \u03c3 and the type \u03c4."),r.createElement(i,{value:u.intersection_type})),r.createElement(l.n,null,r.createElement(l.r,null,"Union type"),r.createElement(l.r,null,"A union type describes a value that can be one of several types."),r.createElement(i,{value:u.union_type})),r.createElement(l.n,null,r.createElement(l.r,null,"Lattice"),r.createElement(l.r,null,r.createElement("a",{href:"https://en.wikipedia.org/wiki/Lattice_(order)#Bounded_lattice",about:"_blank"},"Bounded lattice")),r.createElement("img",{src:p.a,alt:"Hasse diagram of powerset of 3"})),r.createElement(l.n,null,r.createElement(l.r,null,"Type lattice"),r.createElement("img",{style:{width:631,height:502,marginLeft:"auto",marginRight:"auto"},src:y.a,alt:"Hasse diagram of type system"})),r.createElement(l.n,null,r.createElement(l.r,null,"Type lattice"),r.createElement(i,{value:u.type_lattice})),r.createElement(l.n,null,r.createElement(l.r,null,"string literals and enum type"),r.createElement(l.r,null,"enum is nominal typing."),r.createElement(i,{value:u.string_literals_and_enum_types})),r.createElement(l.n,null,r.createElement(l.r,null,"variance : covariant / contravariant / invariant"),r.createElement(i,{value:u.variance})),r.createElement(l.n,null,r.createElement(l.r,null,"bivariance"),r.createElement(i,{value:u.variance_bivariance})),r.createElement(l.n,null,r.createElement(l.r,null,"discriminated union"),r.createElement(i,{value:u.discriminated_union})),r.createElement(l.n,null,r.createElement(l.r,null,"function"),r.createElement(i,{value:u.function_type})),r.createElement(l.n,null,r.createElement(l.r,null,"index types"),r.createElement(i,{value:u.index_types})),r.createElement(l.n,null,r.createElement(l.r,null,"mapped types"),r.createElement(i,{value:u.mapped_types})),r.createElement(l.n,null,r.createElement(l.r,null,"contextual typing"),r.createElement(i,{value:u.contextual_typing})),r.createElement(l.n,null,r.createElement(l.r,null,"class"),r.createElement(i,{value:u.class_type})),r.createElement(l.n,null,r.createElement(l.r,null,"conditional types"),r.createElement(i,{value:u.conditional_types})),r.createElement(l.n,null,r.createElement(l.r,null,"type guards and asserts"),r.createElement(i,{value:u.type_guards_and_asserts})),r.createElement(l.n,null,r.createElement(l.r,null,"Nominal typing and structural typing"),r.createElement(l.r,null,"A static type checker uses either the names or the structure of the types in order to compare them against other types. Checking against the name is nominal typing and checking against the structure is structural typing.")),r.createElement(l.n,null,r.createElement(l.r,null,"Structural typing is a way of relating types based solely on their members."),r.createElement(i,{value:u.structural_typing})),r.createElement(l.n,null,r.createElement(l.r,null,"Declaration spaces"),r.createElement(l.r,null,r.createElement(i,{value:u.declaration_spaces}))),r.createElement(l.n,null,r.createElement(l.r,null,"Soundness and Completeness of the Type System"),r.createElement(i,{value:u.soundness_and_completeness})),r.createElement(l.n,null,r.createElement(l.r,null,"Soundness and Completeness of the Type System"),r.createElement(l.s,null,r.createElement(l.i,null,"A type-system is sound implies that all of type-checked programs are correct (in the other words, all of the incorrect program can't be type checked), i.e. there won't be any false negative."),r.createElement(l.i,null,"A type-system is complete implies that all of the correct program can be accepted by the type checker, i.e. there won't be any false positive"))),r.createElement(l.n,null,r.createElement(l.r,null,"Besides, according to Godel's incompleteness theorems, if your system is expressive enough to represent natural numbers, then it can't be both sound and complete."),r.createElement(l.r,null,"Usually, most programming language would prefer soundness over completeness, since false negative will result in bad consequence.")),r.createElement(l.n,null,r.createElement(l.f,null,"\u4f5c\u4e1a"),r.createElement(l.r,null,"omit\uff0cPromise.all, SimpleVue")))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));a.render(r.createElement(r.StrictMode,null,r.createElement(d,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(e=>{e.unregister()}).catch(e=>{console.error(e.message)})}},[[313,2,3]]]);
//# sourceMappingURL=main.b07ad800.chunk.js.map